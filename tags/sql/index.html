<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>Tag: sql | 宅谈</title>
    <meta name="keywords" content="hexo,theme,otakism,otaku"/>
    <meta name="HandheldFriendly" content="True"/>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="google-site-verification" content=""/>
    <meta name="baidu-site-verification" content=""/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="你还在期待着什么？">
<meta property="og:type" content="website">
<meta property="og:title" content="宅谈">
<meta property="og:url" content="http://example.com/tags/sql/index.html">
<meta property="og:site_name" content="宅谈">
<meta property="og:description" content="你还在期待着什么？">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Freere-Aoki">
<meta name="twitter:card" content="summary">
    

    <!-- Favicon -->
    

    <!-- Font -->
    <link href="https://fonts.googleapis.com/css?family=Inconsolata|Roboto:300,400,700" rel="stylesheet">

    
<link rel="stylesheet" href="/style.css">

    <script>
      function setLoadingBarProgress(num) {
        document.getElementById('loading-bar').style.width = num + "%";
      }
    </script>

    
<meta name="generator" content="Hexo 5.4.0"></head>

<body>

<div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>

<script>setLoadingBarProgress(20)</script>

<div id="site-wrapper">

    <header id="header">
    <div id="header-wrapper" class="clearfix">
        <a id="logo" href="/">
            <img src="/img/logo.png"/>
            <span id="site-desc">
                otaku keeps alive
            </span>
        </a>
        <button id="site-nav-switch">
            <span class="icon icon-menu"></span>
        </button>
    </div>
</header>
    <script>setLoadingBarProgress(40);</script>

    <main id="main" role="main">
        
  <section class="page-header tag">
    <h1>- <span>sql</span> -</h1>
  </section>






<section class="post-list">
  
    
<article class="post ">

    
        <h2 class="title">
            <a href="/2021/03/26/SAP-HANA-PROCEDURE-sap-hana%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/">
                SAP HANA PROCEDURE(sap hana数据库 存储过程)
            </a>
        </h2>
    
    <time>
        3月 26, 2021
    </time>
    <section class="content">
        <h1><span id="存储过程">存储过程</span></h1><p>内容引自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiangzhengjun/p/5040531.html#_Toc473120244">HANA SQLScript</a>第三部分储存过程-创建储存过程<del>是真长</del></p>
<h2><span id="31create-procedure">3.1CREATE PROCEDURE</span></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> [<span class="operator">&lt;</span>schema_name<span class="operator">&gt;</span>.]<span class="operator">&lt;</span>proc_name<span class="operator">&gt;</span> [(<span class="operator">&lt;</span>parameter_clause<span class="operator">&gt;</span>)] [<span class="keyword">LANGUAGE</span> <span class="operator">&lt;</span>lang<span class="operator">&gt;</span>] [<span class="keyword">SQL</span> SECURITY <span class="operator">&lt;</span>mode<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">DEFAULT</span> SCHEMA <span class="operator">&lt;</span>default_schema_name<span class="operator">&gt;</span>][<span class="keyword">READS</span> <span class="keyword">SQL</span> DATA [<span class="keyword">WITH</span> <span class="keyword">RESULT</span> <span class="keyword">VIEW</span> ]] <span class="keyword">AS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> [SEQUENTIAL EXECUTION]</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span>procedure_body<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>The CREATE PROCEDURE statement creates a procedure using the specified programming language <lang>.</lang></p>
<p>DeepL翻译：CREATE PROCEDURE语句使用指定的编程语言<lang>创建一个过程。</lang></p>
<h3><span id="311">3.1.1   <parameter_clause></parameter_clause></span></h3><ol>
<li><parameter_clause> ::= <parameter> [{,<parameter>}…]<ol>
<li><parameter> ::= [<param_inout>] <param_name> <param_type><ol>
<li><param_inout> ::= IN|OUT|INOUT    </param_inout></li>
<li><param_type> ::= <sql_type> | <table_type> | <table_type_definition>              <ol>
<li><sql_type> ::= DATE | TIME| TIMESTAMP | SECONDDATE | TINYINT | SMALLINT |INTEGER | BIGINT | DECIMAL | SMALLDECIMAL | REAL | DOUBLE<br>| VARCHAR | NVARCHAR | ALPHANUM | VARBINARY | CLOB | NCLOB | BLOB</sql_type></li>
<li><table_type_defintion> ::= TABLE (<column_list_definition>)  <ol>
<li><column_list_definition> ::= <column_elem>[{, <column_elem>}…]<ol>
<li><column_elem> ::= <column_name> <data_type></data_type></column_name></column_elem></li>
</ol>
</column_elem></column_elem></column_list_definition></li>
</ol>
</column_list_definition></table_type_defintion></li>
</ol>
</table_type_definition></table_type></sql_type></param_type></li>
</ol>
</param_type></param_name></param_inout></parameter></li>
</ol>
</parameter></parameter></parameter_clause></li>
</ol>
<p>输入或输出参数类型可以是标准的基础数据类型与表类型，但INOUT参数只能是标准数据类型</p>
<p><param_inout>：默认为IN</param_inout></p>
<p><table_type_defintion>：参数类型如果是表类型，这个表类型可以是预先使用Create Type…As Table语句创建的类型对象，也可以在指定存储过程参数类型时才定义表类型</table_type_defintion></p>
<h3><span id="312-language">3.1.2   LANGUAGE <lang></lang></span></h3><p><lang> ::= SQLSCRIPT | R</lang></p>
<p>默认为: SQLSCRIPT。指定存储过程实现的程序语言</p>
<h3><span id="313-sql-security">3.1.3   SQL SECURITY <mode></mode></span></h3><p><mode> ::= DEFINER | INVOKER</mode></p>
<p>默认: DEFINER，指定存储过程的安全模式</p>
<p>DEFINER：Specifies that the execution of the procedure is performed with the privileges of the definer of the procedure. </p>
<p>DEFINER：只有存储过程的定义者才能执行？</p>
<p>INVOKER：Specifies that the execution of the procedure is performed with the privileges of the invoker of the procedure.</p>
<h3><span id="314-reads-sql-data">3.1.4   READS SQL DATA</span></h3><p>存储过程为只读的，不能包含DDL与DML（INSERT、UPDATE、DELETE）语句（即只能使用查询SQL与DCL语句），如果调用其他存储过程，则被调用过程也是只读的。设置参数会有特定的优化</p>
<h3><span id="315-with-result-view">3.1.5   WITH RESULT VIEW <view_name></view_name></span></h3><p>Specifies the result view to be used as the output of a read-only procedure.将只读取存储过程的输出看做结果视图</p>
<p>When a result view is defined for a procedure, it can be called by an SQL statement in the same way as a tableor view. See Example 2 - Using a result view below.定义了结果视图的存储过程，可以被其他查询SQL用来查询，此时存储过程就像一个表或视图</p>
<h3><span id="316-sequential-execution">3.1.6   SEQUENTIAL EXECUTION</span></h3><p>This statement will force sequential execution of the procedure logic. No parallelism takes place.不允许存储过程并行执行</p>
<h3><span id="317">3.1.7   <procedure_body></procedure_body></span></h3><p><procedure_body> ::= [<proc_decl_list>]              定义块<br>[<proc_handler_list>]            异常处理块<br><proc_stmt_list>                 存储体语句块</proc_stmt_list></proc_handler_list></proc_decl_list></procedure_body></p>
<p>Defines the main body of the procedure according to the programming language selected.过程的主体由设定的程序语言来定义</p>
<h4><span id="3171-定义变量">3.1.7.1    <proc_decl_list> 定义变量</proc_decl_list></span></h4><ol>
<li><proc_decl_list> ::= <proc_decl> [{<proc_decl>}…]<ol>
<li><proc_decl> ::= <strong>DECLARE</strong> {<proc_variable>|<proc_table_variable>|<proc_cursor>|<proc_condition>} ;<ol>
<li><code>&lt;proc_variable&gt;::= &lt;variable_name_list&gt; [**CONSTANT**] &#123;&lt;sql_type&gt;|&lt;array_datatype&gt;&#125;[NOT NULL][&lt;proc_default&gt;]</code><ol>
<li><variable_name_list> ::= <variable_name>[{, &lt;variable_name}…]</variable_name></variable_name_list></li>
<li><array_datatype> ::= <sql_type> ARRAY [ = <array_constructor> ]<ol>
<li><array_constructor> ::= ARRAY (<expression> [ { , <expression> }…] )</expression></expression></array_constructor></li>
</ol>
</array_constructor></sql_type></array_datatype></li>
<li><proc_default> ::= (DEFAULT | ‘=’ ) <value>|<expression></expression></value></proc_default></li>
</ol>
</li>
<li><proc_table_variable> ::= <variable_name_list> {<table_type_definition>|<table_type>}<ol>
<li><variable_name_list> ::= <variable_name>[{, &lt;variable_name}…]</variable_name></variable_name_list></li>
<li><table_type_definition> ::= TABLE(<column_list_elements>)<ol>
<li><column_list_elements> ::= (<column_definition>[{,<column_definition>}…])</column_definition></column_definition></column_list_elements></li>
</ol>
</column_list_elements></table_type_definition></li>
</ol>
</table_type></table_type_definition></variable_name_list></proc_table_variable></li>
<li><proc_cursor> ::= <strong>CURSOR</strong> <cursor_name> [ ( proc_cursor_param_list ) ] <strong>FOR</strong> <subquery> ;<ol>
<li><proc_cursor_param_list> ::= <proc_cursor_param> [{,<proc_cursor_param>}…]<ol>
<li><proc_cursor_param> ::= <param_name> <datatype></datatype></param_name></proc_cursor_param></li>
</ol>
</proc_cursor_param></proc_cursor_param></proc_cursor_param_list></li>
</ol>
</subquery></cursor_name></proc_cursor></li>
<li><proc_condition> ::= <variable_name> CONDITION | <variable_name> CONDITION FOR <sql_error_code></sql_error_code></variable_name></variable_name></proc_condition></li>
</ol>
</proc_condition></proc_cursor></proc_table_variable></proc_variable></proc_decl></li>
</ol>
</proc_decl></proc_decl></proc_decl_list></li>
</ol>
<p><strong>CREATE</strong> <strong>procedure</strong> proc() <strong>LANGUAGE</strong> SQLSCRIPT <strong>AS</strong></p>
<p><strong>BEGIN</strong></p>
<p>​    <strong>declare</strong> a <strong>int****default</strong> 2;–基本类型变量使用前一定要定义</p>
<p>​    – 如果某个变量是表类型的变量，可以不用声明，直接就可以使用，这与基本类型变量是不一样的</p>
<p>​    – ——基本类型变量使用前需要定义</p>
<p>​    –declare tab_var1 table(a int,b int); 表类型变量可不定义就使用</p>
<p>​    a := 1;</p>
<p>​    – a = 1; 基本类型变量赋值时，等号前一定要加冒号，这与表类型变量恰好相反</p>
<p>​    tab_var1 = <strong>select</strong> 1 <strong>as</strong> a,2 <strong>as</strong> b <strong>from</strong> dummy;</p>
<p>​    –tab_var1 := select 1 as a,2 as b from dummy; 这是错误，表类型变量赋值时，只能使用等号，不能在等号前加冒号，这与基本类型变量赋值相反</p>
<p><strong>END</strong>;</p>
<h1><span id="暂时看到这了太长了下次再接着看"><strong>暂时看到这了：太长了下次再接着看</strong></span></h1><h4><span id="3172-异常处理">3.1.7.2    <proc_handler_list> 异常处理</proc_handler_list></span></h4><p><proc_handler_list> ::= <proc_handler> [{, <proc_handler>}…]                </proc_handler></proc_handler></proc_handler_list></p>
<p><proc_handler>::= <a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiangzhengjun/p/5040531.html#_DECLARE_EXIT_HANDLER">DECLARE EXIT HANDLER FOR</a> <proc_condition_value_list> <proc_stmt> ;</proc_stmt></proc_condition_value_list></proc_handler></p>
<p><proc_condition_value_list> ::= <proc_condition_value>{,<proc_condition_value>}…]</proc_condition_value></proc_condition_value></proc_condition_value_list></p>
<p>​                        <proc_condition_value> ::= <a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiangzhengjun/p/5040531.html#_Autonomous_Transaction">SQLEXCEPTION </a>| SQLWARNING | <sql_error_code> | <condition_name></condition_name></sql_error_code></proc_condition_value></p>
<h4><span id="3173-过程体">3.1.7.3    <proc_stmt_list> 过程体</proc_stmt_list></span></h4><p><proc_stmt_list> ::= {<proc_stmt>}…</proc_stmt></proc_stmt_list></p>
<p><proc_stmt> ::= <proc_block>| <proc_assign>| <proc_single_assign>| <proc_multi_assign>| <proc_if>| <proc_loop>| <proc_while>| <proc_for>|<br><proc_foreach>| <proc_exit>| <proc_continue>| <proc_signal>| <proc_resignal>| <proc_sql>| <proc_open>| <proc_fetch>| <proc_close>| <proc_call>| <proc_exec>| <proc_return></proc_return></proc_exec></proc_call></proc_close></proc_fetch></proc_open></proc_sql></proc_resignal></proc_signal></proc_continue></proc_exit></proc_foreach></proc_for></proc_while></proc_loop></proc_if></proc_multi_assign></proc_single_assign></proc_assign></proc_block></proc_stmt></p>
<h5><span id="31731-内嵌块">3.1.7.3.1   <proc_block> 内嵌块</proc_block></span></h5><p><proc_block> ::= BEGIN <proc_block_option>[<proc_decl_list>][<proc_handler_list>] <proc_stmt_list> END ;</proc_stmt_list></proc_handler_list></proc_decl_list></proc_block_option></proc_block></p>
<p><proc_block_option> ::= [SEQUENTIAL EXECUTION] [AUTONOMOUS TRANSACTION]| [AUTONOMOUS TRANSACTION] [SEQUENTIAL<br>                                 EXECUTION]</proc_block_option></p>
<p>内嵌块， BEGIN 、 END是可以内嵌的</p>
<h5><span id="31732-给变量赋值">3.1.7.3.2   <proc_assign> 给变量赋值</proc_assign></span></h5><p><proc_assign> ::= <variable_name> = { <expression> | <array_function> } ;| <variable_name> ‘[‘ <expression> ‘]’ = <expression> ;</expression></expression></variable_name></array_function></expression></variable_name></proc_assign></p>
<p><array_function> = ARRAY_AGG ( <table_variable>.<column_name> [ ORDER BY <sort_spec_list> ] ) | CARDINALITY ( <array_variable_name>) | TRIM_ARRAY<br>( <array_variable_name> , <array_variable_name>) | ARRAY ( <array_variable_name_list> )</array_variable_name_list></array_variable_name></array_variable_name></array_variable_name></sort_spec_list></column_name></table_variable></array_function></p>
<p>​                                        <array_variable_name_list> ::=&lt; array_variable_name &gt; [{, &lt; array_variable_name &gt;}…]  这个是自己 加的，是否正确？</array_variable_name_list></p>
<p>Assign values to variables. An <expression> can be either a simple expression, such as a character, a date, or a number, or it can be a scalar function or a scalar user-defined function.将值赋给变量。<expression>可以是一个简单的表达式（如字符、日期、数字表达式），或者是标准函数，或用户自定义函数</expression></expression></p>
<p>有关 ARRAY 、ARRAY_AGG、CARDINALITY、TRIM_ARRAY函数请参考后面数组函数</p>
<h5><span id="31733-单个赋值">3.1.7.3.3   <proc_single_assign> 单个赋值</proc_single_assign></span></h5><p><proc_single_assign> ::= <variable_name> = <subquery> | <variable_name> = <proc_ce_call> | <variable_name> = <proc_apply_filter>| <variable_name> =<br><unnest_function></unnest_function></variable_name></proc_apply_filter></variable_name></proc_ce_call></variable_name></subquery></variable_name></proc_single_assign></p>
<p><proc_ce_call> ::= TRACE ( <variable_name> ) ;| CE_LEFT_OUTER_JOIN ( <table_variable> , <table_variable> ,’[‘ <expr_alias_comma_list> ‘]’ <expr_alias_vector>] ) ;<br> | CE_RIGHT_OUTER_JOIN ( <table_variable> , <table_variable> ,’[‘ <expr_alias_comma_list> ‘]’ [ <expr_alias_vector>] ) ; | CE_FULL_OUTER_JOIN ( <table_variable> , <table_variable> ,’[‘ <expr_alias_comma_list> ‘]’ [ <expr_alias_vector>] ); | CE_JOIN ( <table_variable> , <table_variable> , ‘[‘<expr_alias_comma_list> ‘]’ [<expr_alias_vector>] ) ;| CE_UNION_ALL ( <table_variable> , <table_variable> ) ;| CE_COLUMN_TABLE ( <table_name> [ <expr_alias_vector>] ) ; | CE_JOIN_VIEW ( <table_name> [ <expr_alias_vector>] ) ;| CE_CALC_VIEW ( <table_name> [ <expr_alias_vector>] ) ; | CE_OLAP_VIEW ( <table_name> [ <expr_alias_vector>] ) ; | CE_PROJECTION ( <table_variable> , ‘[‘<expr_alias_comma_list> ‘]’ <opt_str_const> ) ; | CE_PROJECTION ( <table_variable> <opt_str_const> ) ; | CE_AGGREGATION ( <table_variable> , ‘[‘<agg_alias_comma_list> ‘]’ [ <expr_alias_vector>] ); | CE_CONVERSION ( <table_variable> , ‘[‘<proc_key_value_pair_comma_list> ‘]’ [ <expr_alias_vector>] ) ;| CE_VERTICAL_UNION ( <table_variable> , ‘[‘<expr_alias_comma_list> ‘]’ <vertical_union_param_pair_list> ) ;| CE_COMM2R ( <table_variable> , <int_const> , <str_const> ,<int_const> , <int_const> , <str_const> ) ;</str_const></int_const></int_const></str_const></int_const></table_variable></vertical_union_param_pair_list></expr_alias_comma_list></table_variable></expr_alias_vector></proc_key_value_pair_comma_list></table_variable></expr_alias_vector></agg_alias_comma_list></table_variable></opt_str_const></table_variable></opt_str_const></expr_alias_comma_list></table_variable></expr_alias_vector></table_name></expr_alias_vector></table_name></expr_alias_vector></table_name></expr_alias_vector></table_name></table_variable></table_variable></expr_alias_vector></expr_alias_comma_list></table_variable></table_variable></expr_alias_vector></expr_alias_comma_list></table_variable></table_variable></expr_alias_vector></expr_alias_comma_list></table_variable></table_variable></expr_alias_vector></expr_alias_comma_list></table_variable></table_variable></variable_name></proc_ce_call></p>
<p><table_name> ::= [<schema_name>.]<identifier></identifier></schema_name></table_name></p>
<p><proc_apply_filter> ::= APPLY_FILTER ( {<table_name> | <table_variable>},<variable_name> ) ;</variable_name></table_variable></table_name></proc_apply_filter></p>
<p><unnest_function> ::= UNNEST ( <variable_name_list> ) [ WITH ORDINALITY ][<as_col_names>] ;</as_col_names></variable_name_list></unnest_function></p>
<p><variable_name_list> ::= <variable_name> [{, <variable_name>}…]</variable_name></variable_name></variable_name_list></p>
<p><as_col_names> ::= AS [table_name] ( <column_name_list> )</column_name_list></as_col_names></p>
<p><column_name_list> ::= <column_name>[{, <column_name>}…]</column_name></column_name></column_name_list></p>
<p>WITH ORDINALTIY：Appends an ordinal column to the return values.</p>
<h5><span id="31734-多个赋值">3.1.7.3.4   <proc_multi_assign> 多个赋值</proc_multi_assign></span></h5><p><proc_multi_assign> ::= (<var_name_list>) = <function_expression></function_expression></var_name_list></proc_multi_assign></p>
<p>Assign values to a list of variables with only one function evaluation. For example, <function_expression>must be a scalar user defined function and the number of elements in <var_name_list> must be equal to the number of output parameters of the scalar UDF（用户定义函数）.</var_name_list></function_expression></p>
<p><function_expression>：用户自定义函数</function_expression></p>
<p>函数的输入参数个数需与<var_name_list>中的参数个数相同</var_name_list></p>
<h5><span id="31735">3.1.7.3.5   <proc_if></proc_if></span></h5><p><proc_if> ::= <strong>IF</strong> <condition> <strong>THEN</strong> [SEQUENTIAL EXECUTION][<proc_decl_list>] [<proc_handler_list>] <proc_stmt_list> [<proc_elsif_list>] [<proc_else>] <strong>END IF</strong> ;</proc_else></proc_elsif_list></proc_stmt_list></proc_handler_list></proc_decl_list></condition></proc_if></p>
<p><proc_elsif_list> ::= <strong>ELSEIF</strong> <condition> <strong>THEN</strong> [SEQUENTIAL EXECUTION][<proc_decl_list>] [<proc_handler_list>] <proc_stmt_list></proc_stmt_list></proc_handler_list></proc_decl_list></condition></proc_elsif_list></p>
<p><proc_else> ::= <strong>ELSE</strong> [SEQUENTIAL EXECUTION][<proc_decl_list>][<proc_handler_list>] <proc_stmt_list></proc_stmt_list></proc_handler_list></proc_decl_list></proc_else></p>
<p>You use IF - THEN - ELSE IF to control execution flow with conditionals.</p>
<h5><span id="31736">3.1.7.3.6   <proc_loop></proc_loop></span></h5><p><proc_loop> ::= <strong>LOOP</strong> [SEQUENTIAL EXECUTION][<proc_decl_list>] [<proc_handler_list>] <proc_stmt_list> <strong>END LOOP</strong> ;</proc_stmt_list></proc_handler_list></proc_decl_list></proc_loop></p>
<p>You use loop to repeatedly execute a set of statements.</p>
<h5><span id="31737">3.1.7.3.7   <proc_while></proc_while></span></h5><p><proc_while> ::= <strong>WHILE</strong> <condition> <strong>DO</strong> [SEQUENTIAL EXECUTION][<proc_decl_list>] [<proc_handler_list>] <proc_stmt_list> <strong>END WHILE</strong> ;</proc_stmt_list></proc_handler_list></proc_decl_list></condition></proc_while></p>
<p>You use while to repeatedly call a set of trigger statements while a condition is true.</p>
<h5><span id="31738">3.1.7.3.8   <proc_for></proc_for></span></h5><p><proc_for> ::= <strong>FOR</strong> <column_name> <strong>IN</strong> [ REVERSE ] <expression> […] <expression> <strong>DO</strong> [SEQUENTIAL EXECUTION]</expression></expression></column_name></proc_for></p>
<p>[<proc_decl_list>]</proc_decl_list></p>
<p> [<proc_handler_list>]</proc_handler_list></p>
<proc_stmt_list>

<p><strong>END FOR</strong> ;</p>
<p>You use FOR - IN loops to iterate over a set of data.</p>
<h5><span id="31739">3.1.7.3.9   <proc_foreach></proc_foreach></span></h5><p><proc_foreach> ::= <strong>FOR</strong> <column_name> <strong>AS</strong> <column_name> [<open_param_list>] <strong>DO</strong> [SEQUENTIAL EXECUTION]</open_param_list></column_name></column_name></proc_foreach></p>
<p>[<proc_decl_list>]</proc_decl_list></p>
<p>[<proc_handler_list>]</proc_handler_list></p>
<proc_stmt_list>

<p>END <strong>FOR</strong> ;</p>
<p><open_param_list> ::= ( <expression> [ { , <expression> }…] )</expression></expression></open_param_list></p>
<p>You use FOR - EACH loops to iterate over all elements in a set of data.</p>
<h5><span id="317310">3.1.7.3.10   <proc_exit></proc_exit></span></h5><p><proc_exit> ::= BREAK ;</proc_exit></p>
<p>Terminates a loop.结束循环</p>
<h5><span id="317311">3.1.7.3.11   <proc_continue></proc_continue></span></h5><p><proc_continue> ::= CONTINUE ;</proc_continue></p>
<p>Skips a current loop iteration and continues with the next value.结束当前循环继续下一次循环</p>
<h5><span id="317312">3.1.7.3.12   <proc_signal></proc_signal></span></h5><p><proc_signal> ::= SIGNAL <signal_value> [<set_signal_info>] ;</set_signal_info></signal_value></proc_signal></p>
<p>You use the SIGNAL statement to explicitly raise an exception from within your trigger procedures.</p>
<h5><span id="317313">3.1.7.3.13   <proc_resignal></proc_resignal></span></h5><p><proc_resignal> ::= RESIGNAL [<signal_value>] [<set_signal_info>] ;</set_signal_info></signal_value></proc_resignal></p>
<p>You use the RESIGNAL statement to raise an exception on the action statement in an exception handler. If an error code is not specified, RESIGNAL will throw the caught exception.重新抛出异常？</p>
<p><signal_value> ::= <signal_name> | <sql_error_code></sql_error_code></signal_name></signal_value></p>
<p><signal_name> ::= <identifier></identifier></signal_name></p>
<p><sql_error_code> ::= <unsigned_integer></unsigned_integer></sql_error_code></p>
<p>You can SIGNAL or RESIGNAL a signal name or an SQL error code.</p>
<p><set_signal_info> ::= SET MESSAGE_TEXT = ‘<message_string>‘</message_string></set_signal_info></p>
<p><message_string> ::= <any_character></any_character></message_string></p>
<p>You use SET MESSAGE_TEXT to deliver an error message to users when specified error is thrown during procedure execution.</p>
<h5><span id="317314">3.1.7.3.14   <proc_sql></proc_sql></span></h5><p><proc_sql> ::= <subquery> | <select_into_stmt> | <insert_stmt> | <delete_stmt> | <update_stmt> | <replace_stmt> | <call_stmt> | <create_table> | <drop_table></drop_table></create_table></call_stmt></replace_stmt></update_stmt></delete_stmt></insert_stmt></select_into_stmt></subquery></proc_sql></p>
<p><insert_stmt>, <delete_stmt>,<update_stmt>,<replace_stmt> and <upsert_stmt>请参考HANA SQL中INSERT , DELETE, UPDATE, REPLACE and UPSERT SQL语句</upsert_stmt></replace_stmt></update_stmt></delete_stmt></insert_stmt></p>
<p><select_into_stmt> ::= SELECT <select_list> INTO <var_name_list> <from_clause> [<where_clause>] [<group_by_clause>] [<having_clause>] [{<set_operator><br><subquery>, … }] [<order_by_clause>] [<limit>] ;</limit></order_by_clause></subquery></set_operator></having_clause></group_by_clause></where_clause></from_clause></var_name_list></select_list></select_into_stmt></p>
<p><var_name_list> ::= <var_name>[{, <var_name>}…]   <var_name>为基础类型变量</var_name></var_name></var_name></var_name_list></p>
<h5><span id="317315">3.1.7.3.15   <proc_open>、<proc_fetch>、<proc_close></proc_close></proc_fetch></proc_open></span></h5><p><proc_open> ::= OPEN <cursor_name> [ <open_param_list>] ;</open_param_list></cursor_name></proc_open></p>
<p><proc_fetch> ::= FETCH <cursor_name> INTO <column_name_list> ;</column_name_list></cursor_name></proc_fetch></p>
<p><proc_close> ::= CLOSE <cursor_name> ;</cursor_name></proc_close></p>
<p>Cursor operations</p>
<h5><span id="317316">3.1.7.3.16   <proc_call></proc_call></span></h5><p><proc_call> ::= CALL <proc_name> (<param_list>) ;</param_list></proc_name></proc_call></p>
<p>Calling a procedure</p>
<h5><span id="317317">3.1.7.3.17   <proc_exec></proc_exec></span></h5><p><proc_exec> ::= {EXEC | EXECUTE IMMEDIATE} <proc_expr> ;</proc_expr></proc_exec></p>
<p>You use EXEC to make dynamic SQL calls.</p>
<h5><span id="317318">3.1.7.3.18   <proc_return></proc_return></span></h5><p><proc_return> ::= RETURN [<proc_expr>] ;</proc_expr></proc_return></p>
<p>Return a value from a procedure.</p>
<h3><span id="318-examples">3.1.8   Examples</span></h3><p>Example 1 - Creating an SQL Procedure</p>
<p>You create an SQLScript procedure with the following definition.</p>
<p><strong>CREATE<strong><strong>COLUMN</strong></strong>TABLE</strong>“SYSTEM”.”T” (“ID”<strong>INTEGER</strong> CS_INT,</p>
<p>​     “NAME”<strong>VARCHAR</strong>(30),</p>
<p>​     “PAYMENT”<strong>INTEGER</strong> CS_INT) <strong>UNLOAD****PRIORITY</strong> 5 AUTO <strong>MERGE</strong>;</p>
<p><strong>insert****into</strong>“SYSTEM”.”T”<strong>values</strong>(1,’a’,10);</p>
<p><strong>insert****into</strong>“SYSTEM”.”T”<strong>values</strong>(2,’b’,20);</p>
<p><strong>insert****into</strong>“SYSTEM”.”T”<strong>values</strong>(3,’c’,30);</p>
<p><strong>CREATE****PROCEDURE</strong> orchestrationProc <strong>LANGUAGE</strong> SQLSCRIPT <strong>AS</strong></p>
<p><strong>BEGIN</strong></p>
<p>​    <strong>DECLARE</strong> v_id <strong>INT</strong>;</p>
<p>​    <strong>DECLARE</strong> v_name <strong>VARCHAR</strong>(30);</p>
<p>​    <strong>DECLARE</strong> v_pmnt <strong>INT</strong>;</p>
<p>​    <strong>DECLARE</strong> v_msg <strong>VARCHAR</strong>(200);</p>
<p>​    <strong>DECLARE****CURSOR</strong> c_cursor1 (p_payment <strong>INT</strong>) <strong>FOR****SELECT</strong> id, name, PAYMENT <strong>FROM</strong> t</p>
<p>​           <strong>WHERE</strong> payment &gt;= p_payment <strong>ORDER****BY</strong> id <strong>ASC</strong>;</p>
<p>​    <strong>OPEN</strong> c_cursor1(20);</p>
<p>​    <strong>FETCH</strong> c_cursor1 <strong>INTO</strong> v_id, v_name, v_pmnt;</p>
<p>​    v_msg := v_name || ‘ (id ‘ || v_id || ‘) earns ‘ || v_pmnt || ‘ $.’;</p>
<p>​    <strong>select</strong> v_msg <strong>from</strong> dummy;</p>
<p>​    <strong>CLOSE</strong> c_cursor1;</p>
<p><strong>end</strong>;</p>
<p>Example 2 - Using a result view</p>
<p>创建带返回视图结果的存储过程：</p>
<p><strong>CREATE****PROCEDURE</strong> ProcWithResultView(<strong>IN</strong> id <strong>INT</strong>, <strong>OUT</strong> o1 t)</p>
<p><strong>LANGUAGE</strong> SQLSCRIPT</p>
<p>READS <strong>SQL</strong> DATA <strong>WITH</strong> RESULT <strong>VIEW</strong> ProcView <strong>AS</strong></p>
<p><strong>BEGIN</strong></p>
<p>o1 = <strong>SELECT</strong> * <strong>FROM</strong> t <strong>WHERE</strong> id = :id;</p>
<p><strong>END</strong>;</p>
<p>调用存储视图：</p>
<p><strong>select</strong> * <strong>from</strong> ProcView <strong>with</strong> parameters (‘placeholder’ = (‘</p>
<p>idid</p>
<p>‘ ,’2’ ));</p>
<p><strong>CREATE****PROCEDURE</strong> Proc_test(<strong>IN</strong> id <strong>INT</strong>,<strong>IN</strong> name <strong>varchar</strong>(3),<strong>OUT</strong> o1 “SYSTEM”.”T_COLUMN”)</p>
<p><strong>LANGUAGE</strong> SQLSCRIPT</p>
<p>READS <strong>SQL</strong> DATA <strong>WITH</strong> RESULT <strong>VIEW</strong> Proc_View <strong>AS</strong></p>
<p><strong>BEGIN</strong></p>
<p>outt = CE_COLUMN_TABLE(“SYSTEM”.”T_COLUMN”,[id,name,payment]);</p>
<p>–注：过滤条件一定要使用单引号整体引起来；列名一定要使用双引号引起来；</p>
<p>–如果是字符串，则要使用单引号引起来，因为外层有单引号，所以里面要使用两个单引号代表一个单引号</p>
<p>–o1 = CE_PROJECTION(:outt,[id,name,payment],’”ID” = :id AND “NAME” = ‘’:name’’’);</p>
<p>–上面这句等效于下面两句</p>
<p>o1 = CE_PROJECTION(:outt,[id,name,payment],’”ID” = :id’);</p>
<p>o1 = CE_PROJECTION(:o1,[id,name,payment],’”NAME” = ‘’:name’’’);</p>
<p><strong>END</strong>;</p>
<p><strong>select</strong> * <strong>from</strong> Proc_View <strong>with</strong> parameters (‘placeholder’ = (‘</p>
<p>idid</p>
<p>‘ ,’2’ ),’placeholder’ = (‘namename’ ,’b’ ));</p>
<p>Note</p>
<p>Procedures and result views produced by procedures are not connected from the security perspective and therefore do not inherit privileges from each other. The security aspects of each object must be handled separately. For example, you must grant the SELECT privilege on a result view and EXECUTE privilege on a connected procedure.</p>
<img src="\img\7a1c08c79f3df8dccd0ae9edda11728b461028ed.gif" alt="7a1c08c79f3df8dccd0ae9edda11728b461028ed" style="zoom:100%;">



</proc_stmt_list></proc_stmt_list>

        

        
            <div class="tags">
                <a class="tag-none-link" href="/tags/sql/" rel="tag">sql</a><a class="tag-none-link" href="/tags/study/" rel="tag">study</a>
            </div>
        

    </section>
</article>

  
    
<article class="post ">

    
        <h2 class="title">
            <a href="/2021/03/24/Oracle%E4%B8%AD%E7%9A%84translate%E5%87%BD%E6%95%B0%E5%92%8Creplace%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/">
                Oracle中的translate函数和replace函数的用法
            </a>
        </h2>
    
    <time>
        3月 24, 2021
    </time>
    <section class="content">
        <p>接触到此函数目的是为了判断某一单元格数据是在这里插入代码片否为纯数字，虽然实际来说TRANSLATE()实际不是为了判断数据格式。</p>
<p><strong>translate函数语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">translate</span>(expr, from_string, to_string)</span><br></pre></td></tr></table></figure>

<p>功能：在expr中寻找匹配from_string中符合的字符下标，随后根据下标去to_string中寻找对应的字符替换掉expr中对应下标的字符。</p>
<p>expr：进行处理匹配替换的数据</p>
<p>from_string：需要在expr中寻找匹配的字符</p>
<p>to_string：替换在from_string中找到的expr中对应下标的字符</p>
<p><strong>栗子：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">translate</span>(<span class="string">&#x27;ac&#x27;</span>,<span class="string">&#x27;ab2&#x27;</span>,<span class="string">&#x27;00&#x27;</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">--return 0c</span></span><br></pre></td></tr></table></figure>

<p>首先拿出ac中的a去匹配ab2中的字符，他会一个字符一个字符的进行判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a==a <span class="literal">true</span>      	<span class="comment">//a和ab2中的第一个字符比较，结果正确</span></span><br><span class="line">a==b <span class="literal">false</span>      <span class="comment">//a和ab2中的第二个字符比较，结果错误</span></span><br><span class="line">a==<span class="number">2</span> <span class="literal">false</span>      <span class="comment">//a和ab2中的第三个字符比较，结果错误</span></span><br></pre></td></tr></table></figure>

<p>而其中的a匹配到了ab2中的字符，a在ab2中为第一位，所以也去00中寻找第一位进行替换，这时是0c。</p>
<p>再去匹配第二位的c，而在ab2中没有找到，所以不进行替换。</p>
<p>所以返回的结果为0c。</p>
<p><strong>栗子ii：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">translate</span>(<span class="string">&#x27;ac1&#x27;</span>,<span class="string">&#x27;abc123&#x27;</span>,<span class="string">&#x27;abc&#x27;</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">--return ac</span></span><br></pre></td></tr></table></figure>

<p>当to_string比from_string短时，会对多余的位数进行剔除</p>
<p>这里中进行匹配到最后的1时，发现1在abc123中位置为第四位，而通过第四位去替换，去寻找abc的第四位时发现abc没有第四位，这时会将1剔除，返回的结果为ac。</p>
<p>  需要注意的是，to_str不能是NULL或者’’，否则会返回空值。</p>
<ol>
<li>translate也不能用于CLOB，再说得简单一点，也就是<br>如果string中的字符如果在from_string中没有，那么返回时被保留</li>
<li>如果string中的字符是from_string中的”额外字符”，那么返回时被删除</li>
<li>如果string中的字符在from_string中找到，且在to_string中有相应位置的字符，那么返回时用to_string中的字符替换string中的字符</li>
</ol>
<p><strong>replace函数</strong></p>
<p><strong>语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLACE(expr, from_string,to_string)</span><br></pre></td></tr></table></figure>

<p>功能：用法和上文中的translate的用法相同，唯一不同的是translate是会对expr中的字符一个一个和from_string进行匹配，而replace却类似于模糊查询like，会在expr中查找包含from_string的部分并且进行替换为to_string。</p>
<p>expr：进行处理匹配替换的数据</p>
<p>from_string：需要在expr中寻找匹配的字符</p>
<p>to_string：替换在from_string中找到的expr中对应下标的字符</p>
<p><strong>栗子：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> REPLACE(<span class="string">&#x27;fgsgswsgs&#x27;</span>, <span class="string">&#x27;fk&#x27;</span> ,<span class="string">&#x27;j&#x27;</span>) 返回值 <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">--return  fgsgswsgs</span></span><br><span class="line"><span class="keyword">select</span> REPLACE(<span class="string">&#x27;fgsgswsgs&#x27;</span>, <span class="string">&#x27;sg&#x27;</span> ,<span class="string">&#x27;eeerrrttt&#x27;</span>) 返回值 <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">--return  fgeeerrrtttsweeerrrttts</span></span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<p>第一个例子中由于’fgsgswsgs’中没有与’fk’匹配的字符串，</p>
<p>​      故返回值仍然是’fgsgswsgs’；</p>
<p>​      第二个例子中将’fgsgswsgs’中的字符串’sg’全部转换为’eeerrrttt’。</p>
<p>总结：综上所述，replace与translate都是替代函数，</p>
<p>​     只不过replace针对的是字符串，而translate针对的是单个字符。</p>
<p><strong>和replace函数的区别</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">translate</span>(<span class="string">&#x27;itmyhome#163%com&#x27;</span>, <span class="string">&#x27;#%&#x27;</span>, <span class="string">&#x27;@.&#x27;</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">--return itmyhome@163.com</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> replace(<span class="string">&#x27;itmyhome#163%com&#x27;</span>, <span class="string">&#x27;#%&#x27;</span>, <span class="string">&#x27;@.&#x27;</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">--return  itmyhome#163%com</span></span><br></pre></td></tr></table></figure>

<p>上面的translate函数是将#替换为@，%替换为.</p>
<p>而replace却没有实现此效果，是因为没有找到#%整体的组合</p>
<p>部分引自</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010104750/article/details/52388609">translate函数的用法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jb51.net/article/128565.htm">Oracle中的translate函数和replace函数的用法详解</a></li>
</ul>
<img class="bigimg" src="\img\53186325_p0.jpg" alt="53186325_p0" style="zoom:100%;">

<p><em><strong>戦いの前夜</strong></em></p>


        

        
            <div class="tags">
                <a class="tag-none-link" href="/tags/sql/" rel="tag">sql</a><a class="tag-none-link" href="/tags/study/" rel="tag">study</a>
            </div>
        

    </section>
</article>

  
    
<article class="post ">

    
        <h2 class="title">
            <a href="/2021/03/15/%E5%BC%80%E7%AA%97%E5%87%BD%E6%95%B0/">
                开窗函数
            </a>
        </h2>
    
    <time>
        3月 15, 2021
    </time>
    <section class="content">
        <h5><span id="排序函数">排序函数</span></h5><p>开窗函数over()，包含三个分析子句:分组(partition by), 排序(order by), 窗口(rows) ，他们的使用形式如下：over(partition by 排序字段 order by 分区字段 rows between 开窗规则)。</p>
<p>开窗函数<br>   Oracle从8.1.6开始提供分析函数，分析函数用于计算基于组的某种聚合值，它和聚合函数的不同之处是：对于每个组返回多行，而聚合函数对于每个组只返回一行。</p>
<p>   开窗函数指定了分析函数工作的数据窗口大小，这个数据窗口大小可能会随着行的变化而变化，</p>
<p>示例数据：</p>
<img src="\img\QQ截图20210312144133.png" alt="QQ截图20210312144133" style="zoom:80%;">

<p>第一大类：<strong>聚合开窗函数</strong>====》聚合函数(列) OVER (选项)</p>
<p>：sum(),count()等都可以拼接</p>
<p>第二大类：<strong>排序开窗函数</strong>====》排序函数(列) OVER(选项)</p>
<p>：rank(),row_number()等需要和over一起使用排序函数</p>
<p><em><strong>不限于此，很多函数都可以配合over（），在这里不做过多介绍</strong></em></p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--select 函数名()over(partition by 需要分区的列名 order by 想排序的列名 rows/range </span></span><br><span class="line"> <span class="comment">--unbounded preceding and unbouned following针对当前所有记录的前一条、后一条记录，也就是表中的所有记录</span></span><br><span class="line">            <span class="comment">--unbounded：不受控制的，无限的</span></span><br><span class="line">            <span class="comment">--preceding：在...之前</span></span><br><span class="line">            <span class="comment">--following：在...之后</span></span><br><span class="line">          <span class="comment">--  BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) from 表名</span></span><br><span class="line"><span class="comment">--such as </span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span>,<span class="built_in">sum</span>(sage)<span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> sage <span class="keyword">rows</span> <span class="keyword">between</span> UNBOUNDED preceding <span class="keyword">and</span> UNBOUNDED following)</span><br><span class="line"><span class="keyword">from</span> &quot;student&quot;</span><br></pre></td></tr></table></figure>

<p><strong>分区（partition by ）：</strong></p>
<p>功能与group by几乎相同，但group by对于聚合的分组只显示一行数据，并且select后的字段如果其中一个被group by，那么其他字段要么是聚合函数要么也被group by分组聚合。</p>
<p>栗子：分别求男女同学年龄总和</p>
<img src="\img\QQ截图20210315093653.png" alt="QQ截图20210315093653" style="zoom:80%;">

<p>而聚合函数搭配over（）可以一组返回多行数据，而且其他字段不需要为被分组或被聚合。</p>
<p><strong>排序（order by）：</strong></p>
<p>栗子：男女分别根据年龄降序排列</p>
<img src="\img\QQ截图20210315100337.png" alt="QQ截图20210315100337" style="zoom:80%;">



<p>没什么需要多说的，这里使用了rank()函数排序，partition by相当于group by，order by还是原意。</p>
<p>注：关于rank()等排序函数请移步其他文章，本文不做说明</p>
<p>栗子ii：男女按照年龄降序分别求出年龄累计</p>
<img src="\img\QQ截图20210315135813.png" alt="QQ截图20210315135813" style="zoom:80%;">

<p>这里发生了变化，当使用sum()或count()配合over使用，并且使用partition by和order by，就会根据排序进行逐渐的累加或者求和，可以用于计算各个月份随时间累计数等情况</p>
<p><strong>窗口（rows/range）注：rows可以使用，但是range没研究明白报错：</strong></p>
<p>在Over子句中，使用Rows 或Range 进一步限制分区的数据行，在使用时，必须注意：</p>
<p>必需条件：如果使用Rows 或 Range必须跟在Order by 子句之后，对排序的结果进行限制；<br>Rows：使用固定的行数来限制分区中的数据行数量；The ROWS clause limits the rows within a partition by specifying a fixed number of rows preceding or following the current row.<br>Range：使用Value的范围来限制分区中的数据行数量，排序列的重复值，被认为是一个值；The RANGE clause logically limits the rows within a partition by specifying a range of values with respect to the value in the current row.<br>在分区中，如果排序行不存在重复值，Rows和Range返回的结果是相同的；如果排序行存储在重复值，Rows和Range返回的结果可能不同；<br>Range子句只能从分区的开始或结尾到当前行开始计算，不能使用 <uint_number> PRECEDING 和<uint_number>  FOLLOWING；<br>使用在Rows 和 Range子句中的特殊关键字：</uint_number></uint_number></p>
<p>UNBOUNDED PRECEDING：指定分区的第一行<br>UNBOUNDED FOLLOWING：指定分区的最后一行<br>CURRENT ROW：指定分区的当前数据行<br><uint_number> PRECEDING：在分区中，指定当前行之前的数据行数量，UINT_Number是&gt;=0的整数<br><uint_number> FOLLOWING：在分区中，指定当前行之后的数据行数量，UINT_Number是&gt;=0的整数</uint_number></uint_number></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--每行数据都会被开窗影响，每行数据都会根据开窗的行数来向上或向下进行函数的操作。</span></span><br><span class="line"><span class="comment">--当上面没有行时上面的行不做影响，下面也没有行时同上。</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span>,<span class="built_in">sum</span>(sage)<span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> sage <span class="keyword">rows</span> <span class="keyword">between</span> 前多少行 preceding <span class="keyword">and</span> 后多少行 following)</span><br><span class="line"><span class="keyword">from</span> &quot;student&quot;</span><br></pre></td></tr></table></figure>

<p>栗子：对分区中的连续两行计算加和，将每行和下一行进行相加</p>
<img src="\img\QQ截图20210315150441.png" alt="QQ截图20210315150441" style="zoom:80%;">

<p>第一行=第一行sage+第二行sage，第二行=第二行sage+第三行sage………..以此类推</p>
<p>图中第五行数据和第十行数据都是分区中的最后一行数据，没有下面的行进行相加所以是原数</p>
<p>–栗子ii：对分区中的当前行向下计算加和，将每行到当前分区最底下的进行相加</p>
<p>Could not execute ‘select *,sum(sage)over(order by sage range between unbounded preceding and unbounded following) …’<br>SAP DBTech JDBC: [7]: feature not supported: Window frame specification of RANGE not allowed for this window function: line 1 col 10 (at pos 9)</p>
<img src="\img\202005241421367251716257711.500x0.jpg.webp" alt="202005241421367251716257711.500x0.jpg.webp">

<h1><span id="to-be-continued多半是鸽了"><strong><u><em>to</em> <em>be</em> continued（多半是鸽了😜 </u></strong></span></h1>

        

        
            <div class="tags">
                <a class="tag-none-link" href="/tags/sql/" rel="tag">sql</a><a class="tag-none-link" href="/tags/study/" rel="tag">study</a>
            </div>
        

    </section>
</article>

  
    
<article class="post ">

    
        <h2 class="title">
            <a href="/2021/03/12/%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0/">
                排序函数
            </a>
        </h2>
    
    <time>
        3月 12, 2021
    </time>
    <section class="content">
        <h5><span id="排序函数">排序函数：</span></h5><p>  排序函数的作用是基于一个结果集返回一个排序值。排序值就是一个数字，这个数字是典型的以1开始且自增长为1的行值。由排序函数来决定排序值。可以使唯一的对于当前结果集，或者某些行数据有相同的排序值。接下来介绍不同的排序函数以及如何使用这些函数。</p>
<p>示例数据：</p>
<img src="\img\QQ截图20210312144133.png" alt="QQ截图20210312144133" style="zoom:80%;">

<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--select 函数名()over(order by 想排序的列名) from 表名</span></span><br><span class="line"><span class="comment">--such as </span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">rank</span>()<span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ssex <span class="keyword">order</span> <span class="keyword">by</span> sage <span class="keyword">desc</span>) </span><br><span class="line"><span class="keyword">from</span> &quot;student&quot;</span><br></pre></td></tr></table></figure>

<p><em>注：over（）开窗函数用法在此文中不进行介绍</em></p>
<h6><span id="row_number"><strong>ROW_NUMBER()</strong></span></h6><p><strong>定义</strong>：ROW_NUMBER()函数作用就是将select查询到的数据进行排序，每一条数据加一个序号，他不能用做于学生年龄的排名，一般多用于分页查询，因为在遇到相同年龄时序号依然会继续自增，而非并列的序号。</p>
<p><strong>栗子：</strong>根据年龄降序排列学生</p>
<img src="\img\QQ截图20210312145034.png" alt="QQ截图20210312145034" style="zoom:80%;">

<p>ROW_NUMBER（）当遇到相同年龄时序号依然会自增</p>
<h6><span id="rank"><strong>RANK()</strong></span></h6><p><strong>定义：</strong>RANK()函数，顾名思义排名函数，可以对某一个字段进行排名，与ROW_NUMBER()不同，当存在相同年龄的学生时，ROW_NUMBER()会继续进行排序，他们的序号不相同，而Rank()则不一样，当出现相同的年龄时，他们的排名是一样的，并且会跳过已经占用的序号。</p>
<p><strong>栗子：</strong>根据年龄降序排列学生</p>
<img src="\img\QQ截图20210312145927.png" alt="QQ截图20210312145927" style="zoom:80%;">

<p><em>这里第五条数据突然从2号序号跳跃到5号序号，是因为上面已经有四位同学被排序过，按照已经被排序的数据条数就是5号</em></p>
<p>RANK（）当遇到相同年龄时序号时序号不会自增，而是和相同年龄时的序号相同。同时当再次向下排序遇到不同年龄时，会根据已进行排序的条数来跳跃序号。</p>
<h6><span id="dense_rank"><strong>DENSE_RANK()</strong></span></h6><p><strong>定义</strong>：DENSE_RANK()函数也是排名函数，和RANK()功能相似，也是对字段进行排名，那它和RANK()到底有什么不同那？</p>
<p><strong>栗子：</strong>根据年龄降序排列学生</p>
<img src="\img\QQ截图20210312150624.png" alt="QQ截图20210312150624" style="zoom:80%;">

<p>dense_rank函数的功能与rank函数类似，dense_rank函数在生成序号时是连续的，而rank函数生成的序号有可能不连续。dense_rank函数出现相同排名时，将不跳过相同排名号，rank值紧接上一次的rank值。在各个分组内，rank()是跳跃排序，有两个第一名时接下来就是第四名，dense_rank()是连续排序，有两个第一名时仍然跟着第二名。</p>
<p><strong>NTILE()</strong></p>
<p><strong>定义</strong>：ntile函数可以对序号进行分组处理，将有序分区中的行分发到指定数目的组中。 各个组有编号，编号从一开始。 对于每一个行，ntile 将返回此行所属的组的编号。这就相当于将查询出来的记录集放到指定长度的数组中，每一个数组元素存放一定数量的记录。ntile函数为每条记录生成的序号就是这条记录所有的数组元素的索引（从1开始）。也可以将每一个分配记录的数组元素称为“桶”。ntile函数有一个参数，用来指定桶数。</p>
<img src="\img\QQ截图20210312160137.png" alt="QQ截图20210312160137" style="zoom:80%;">

<p><em>将年龄降序并且平均分为四个桶（区）</em></p>
<p>　　ntile函数的分组依据（约定）：</p>
<p>　　<strong>1、每组的记录数不能大于它上一组的记录数，即编号小的桶放的记录数不能小于编号大的桶。就是说，第1组中的记录数只能大于等于第2组及以后各组中的记录数。</strong></p>
<p>　　<strong>2、所有组中的记录数要么都相同，要么从某一个记录较少的组（命名为X）开始后面所有组的记录数都与该组（X组）的记录数相同。也就是说，如果有个组，前三组的记录数都是9，而第四组的记录数是8，那么第五组和第六组的记录数也必须是8。</strong></p>
<p>以上为四个排序函数的用法，最后一个可能不算排序，而是根据排序内容分桶，应用场景一般不为排序。而这些排序函数都依赖于over分窗函数，可以看到排序都是在它之中进行的，同时它也可以使用partition by排序的同时分组，类似于group by，也可以根据row和range进行开窗，但这里不过多解释。！</p>
<p><strong>总结：</strong></p>
<p>在使用排名函数的时候需要注意以下三点：</p>
<p>　　1、排名函数必须有 OVER 子句。</p>
<p>　　2、排名函数必须有包含 ORDER BY 的 OVER 子句。</p>
<p>　　3、分组内从1开始排序。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/52XF/p/4209211.html">引自[Sql 四大排名函数（ROW_NUMBER、RANK、DENSE_RANK、NTILE）简介]</a></p>
<img src="\img\20200429013947.52ff80ba8cacf5780b8e9e93e02e02ef.png" alt="20200429013947.52ff80ba8cacf5780b8e9e93e02e02ef" style="zoom:33%;">



        

        
            <div class="tags">
                <a class="tag-none-link" href="/tags/sql/" rel="tag">sql</a><a class="tag-none-link" href="/tags/study/" rel="tag">study</a>
            </div>
        

    </section>
</article>

  
</section>


        <script>setLoadingBarProgress(60);</script>
    </main>

    <footer id="footer" class="clearfix">

    

    <div class="social-wrapper">
        
            
                <a href="https://github.com/artchen" class="social github"
                   target="_blank" rel="external">
                    <span class="icon icon-github"></span>
                </a>
            
                <a href="/atom.xml" class="social rss"
                   target="_blank" rel="external">
                    <span class="icon icon-rss"></span>
                </a>
            
        
    </div>

    <div class="theme-by">Theme <span class="codename">Memory</span> designed by <a href="https://artifact.me/"
                                                                                    target="_blank">Art Chen</a>.
    </div>
    <div>&copy; <a href="/">宅谈</a></div>

</footer>


    <script>setLoadingBarProgress(80);</script>
    <div class="overlay"></div>
</div>

<div class="site-sidebar" id="site-sidebar">

    

    <div class="sidebar-switch clearfix "
         style="display: none">
        <a class="dark-btn active" data-toggle="toc">
            <span class="icon icon-list"></span>
            <span class="text">Index</span>
        </a>
        <a class="dark-btn" data-toggle="bio">
            <span class="icon icon-person"></span>
            <span class="text">Bio</span>
        </a>
    </div>

    <div class="site-toc "
         style="display: none">
        
            <div class="no-index">No Index</div>
        
    </div>

    <div class="site-bio show"
         style="display: block">

        <div class="about-me clearfix">
            <div class="avatar">
                <img src="/img/avatar.png"/>
            </div>
            <div class="info">
                <a class="name dark-btn" href="/about">
                    Freere-Aoki
                </a>
            </div>
            <div class="info">
                <span class="item desc">
                    你还在期待着什么？
                </span>
            </div>
        </div>

        <div class="menu section">
            <ul class="clearfix">
                
                    <li class="left">
                        <a href="/about"
                           onfocus="this.blur();"
                           class="nav-俺様だ❕ dark-btn block">
                            About
                        </a>
                    </li>
                
                    <li class="right">
                        <a href="/archives"
                           onfocus="this.blur();"
                           class="nav-図書館 dark-btn block">
                            Archives
                        </a>
                    </li>
                
                    <li class="left">
                        <a href="/header"
                           onfocus="this.blur();"
                           class="nav-俺の頭 dark-btn block">
                            Header
                        </a>
                    </li>
                
                    <li class="right">
                        <a href="/gunName"
                           onfocus="this.blur();"
                           class="nav-黑色魅影 dark-btn block">
                            GunName
                        </a>
                    </li>
                
                    <li class="left">
                        <a href="/Links"
                           onfocus="this.blur();"
                           class="nav-友人帐 dark-btn block">
                            LINKS
                        </a>
                    </li>
                
                    <li class="right">
                        <a href="/rolex/主页"
                           onfocus="this.blur();"
                           class="nav-劳力士 dark-btn block">
                            Rolex
                        </a>
                    </li>
                
            </ul>
        </div>

    </div>

    <div class="shortcuts">
        <a href="#header" class="top window-nav dark-btn" id="go-top">
            <span class="icon icon-chevron-thin-up"></span>
        </a>
        <a class="close dark-btn" id="sidebar-close">
            <span class="icon icon-close"></span>
        </a>
        <a href="#footer" class="top window-nav dark-btn" id="go-bottom">
            <span class="icon icon-chevron-thin-down"></span>
        </a>
    </div>

</div>





<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.min.js"><\/script>')</script>


<script src="/js/jquery.fitvids.js"></script>

<script>
  var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
  var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
  var ALGOLIA_API_KEY = "";
  var ALGOLIA_APP_ID = "";
  var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var SEARCH_SERVICE = "";
  var universalSearchConfig = {};
  if (SEARCH_SERVICE === 'google') {
    universalSearchConfig = {
      searchService: SEARCH_SERVICE,
      apiKey: GOOGLE_CUSTOM_SEARCH_API_KEY,
      engineId: GOOGLE_CUSTOM_SEARCH_ENGINE_ID,
      imagePath: "/img/"
    };
  } else if (SEARCH_SERVICE === 'algolia') {
    universalSearchConfig = {
      searchService: SEARCH_SERVICE,
      apiKey: ALGOLIA_API_KEY,
      appId: ALGOLIA_APP_ID,
      indexName: ALGOLIA_INDEX_NAME,
      imagePath: "/img/"
    };
  } else if (SEARCH_SERVICE === 'azure') {
    universalSearchConfig = {
      searchService: SEARCH_SERVICE,
      serviceName: AZURE_SERVICE_NAME,
      indexName: AZURE_INDEX_NAME,
      apiKey: AZURE_QUERY_KEY,
      imagePath: "/img/"
    };
  }
</script>

<script src="/js/app.js"></script>


<script src="/js/search.js"></script>





<script>setLoadingBarProgress(100);</script>

</body>
</html>
